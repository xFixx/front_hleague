"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Hero League API
 * Test description
 *
 * The version of the OpenAPI document: v1
 * Contact: contact@jva.local
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExamsApi = exports.ExamsApiFactory = exports.ExamsApiFp = exports.ExamsApiAxiosParamCreator = exports.CategoriesApi = exports.CategoriesApiFactory = exports.CategoriesApiFp = exports.CategoriesApiAxiosParamCreator = exports.AccountsApi = exports.AccountsApiFactory = exports.AccountsApiFp = exports.AccountsApiAxiosParamCreator = exports.ExamQuestionQuestionTypeEnum = exports.CustomUserCreateRoleEnum = exports.CurrentUserRoleEnum = void 0;
const axios_1 = require("axios");
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("./common");
// @ts-ignore
const base_1 = require("./base");
exports.CurrentUserRoleEnum = {
    Instructor: 'Instructor',
    Volunteer: 'Volunteer',
    Judge: 'Judge',
    Trainer: 'Trainer'
};
exports.CustomUserCreateRoleEnum = {
    Instructor: 'Instructor',
    Volunteer: 'Volunteer',
    Judge: 'Judge',
    Trainer: 'Trainer'
};
exports.ExamQuestionQuestionTypeEnum = {
    R: 'R',
    C: 'C'
};
/**
 * AccountsApi - axios parameter creator
 * @export
 */
exports.AccountsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
         * @param {TokenObtainPair} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthJwtCreateCreate: (data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'data' is not null or undefined
            common_1.assertParamExists('accountsAuthJwtCreateCreate', 'data', data);
            const localVarPath = `/accounts/auth/jwt/create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(data, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
         * @param {TokenRefresh} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthJwtRefreshCreate: (data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'data' is not null or undefined
            common_1.assertParamExists('accountsAuthJwtRefreshCreate', 'data', data);
            const localVarPath = `/accounts/auth/jwt/refresh/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(data, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
         * @param {TokenVerify} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthJwtVerifyCreate: (data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'data' is not null or undefined
            common_1.assertParamExists('accountsAuthJwtVerifyCreate', 'data', data);
            const localVarPath = `/accounts/auth/jwt/verify/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(data, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {Activation} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersActivation: (data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'data' is not null or undefined
            common_1.assertParamExists('accountsAuthUsersActivation', 'data', data);
            const localVarPath = `/accounts/auth/users/activation/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(data, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {CustomUserCreate} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersCreate: (data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'data' is not null or undefined
            common_1.assertParamExists('accountsAuthUsersCreate', 'data', data);
            const localVarPath = `/accounts/auth/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(data, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersDelete: (email, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'email' is not null or undefined
            common_1.assertParamExists('accountsAuthUsersDelete', 'email', email);
            const localVarPath = `/accounts/auth/users/{email}/`
                .replace(`{${"email"}}`, encodeURIComponent(String(email)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersList: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/accounts/auth/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersMeDelete: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/accounts/auth/users/me/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {User} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersMePartialUpdate: (data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'data' is not null or undefined
            common_1.assertParamExists('accountsAuthUsersMePartialUpdate', 'data', data);
            const localVarPath = `/accounts/auth/users/me/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(data, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersMeRead: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/accounts/auth/users/me/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {User} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersMeUpdate: (data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'data' is not null or undefined
            common_1.assertParamExists('accountsAuthUsersMeUpdate', 'data', data);
            const localVarPath = `/accounts/auth/users/me/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(data, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} email
         * @param {User} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersPartialUpdate: (email, data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'email' is not null or undefined
            common_1.assertParamExists('accountsAuthUsersPartialUpdate', 'email', email);
            // verify required parameter 'data' is not null or undefined
            common_1.assertParamExists('accountsAuthUsersPartialUpdate', 'data', data);
            const localVarPath = `/accounts/auth/users/{email}/`
                .replace(`{${"email"}}`, encodeURIComponent(String(email)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(data, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersRead: (email, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'email' is not null or undefined
            common_1.assertParamExists('accountsAuthUsersRead', 'email', email);
            const localVarPath = `/accounts/auth/users/{email}/`
                .replace(`{${"email"}}`, encodeURIComponent(String(email)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {SendEmailReset} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersResendActivation: (data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'data' is not null or undefined
            common_1.assertParamExists('accountsAuthUsersResendActivation', 'data', data);
            const localVarPath = `/accounts/auth/users/resend_activation/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(data, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {SendEmailReset} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersResetPassword: (data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'data' is not null or undefined
            common_1.assertParamExists('accountsAuthUsersResetPassword', 'data', data);
            const localVarPath = `/accounts/auth/users/reset_password/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(data, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {PasswordResetConfirm} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersResetPasswordConfirm: (data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'data' is not null or undefined
            common_1.assertParamExists('accountsAuthUsersResetPasswordConfirm', 'data', data);
            const localVarPath = `/accounts/auth/users/reset_password_confirm/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(data, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {SendEmailReset} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersResetUsername: (data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'data' is not null or undefined
            common_1.assertParamExists('accountsAuthUsersResetUsername', 'data', data);
            const localVarPath = `/accounts/auth/users/reset_email/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(data, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {UsernameResetConfirm} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersResetUsernameConfirm: (data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'data' is not null or undefined
            common_1.assertParamExists('accountsAuthUsersResetUsernameConfirm', 'data', data);
            const localVarPath = `/accounts/auth/users/reset_email_confirm/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(data, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {SetPasswordRetype} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersSetPassword: (data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'data' is not null or undefined
            common_1.assertParamExists('accountsAuthUsersSetPassword', 'data', data);
            const localVarPath = `/accounts/auth/users/set_password/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(data, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {SetUsername} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersSetUsername: (data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'data' is not null or undefined
            common_1.assertParamExists('accountsAuthUsersSetUsername', 'data', data);
            const localVarPath = `/accounts/auth/users/set_email/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(data, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} email
         * @param {User} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersUpdate: (email, data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'email' is not null or undefined
            common_1.assertParamExists('accountsAuthUsersUpdate', 'email', email);
            // verify required parameter 'data' is not null or undefined
            common_1.assertParamExists('accountsAuthUsersUpdate', 'data', data);
            const localVarPath = `/accounts/auth/users/{email}/`
                .replace(`{${"email"}}`, encodeURIComponent(String(email)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(data, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {CurrentUser} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsCreate: (data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'data' is not null or undefined
            common_1.assertParamExists('accountsCreate', 'data', data);
            const localVarPath = `/accounts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(data, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this Пользователь.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsDelete: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('accountsDelete', 'id', id);
            const localVarPath = `/accounts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsList: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/accounts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsMeList: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/accounts/me/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this Пользователь.
         * @param {CurrentUser} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsPartialUpdate: (id, data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('accountsPartialUpdate', 'id', id);
            // verify required parameter 'data' is not null or undefined
            common_1.assertParamExists('accountsPartialUpdate', 'data', data);
            const localVarPath = `/accounts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(data, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this Пользователь.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsRead: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('accountsRead', 'id', id);
            const localVarPath = `/accounts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this Пользователь.
         * @param {CurrentUser} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsUpdate: (id, data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('accountsUpdate', 'id', id);
            // verify required parameter 'data' is not null or undefined
            common_1.assertParamExists('accountsUpdate', 'data', data);
            const localVarPath = `/accounts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(data, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * AccountsApi - functional programming interface
 * @export
 */
exports.AccountsApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.AccountsApiAxiosParamCreator(configuration);
    return {
        /**
         * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
         * @param {TokenObtainPair} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthJwtCreateCreate(data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.accountsAuthJwtCreateCreate(data, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
         * @param {TokenRefresh} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthJwtRefreshCreate(data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.accountsAuthJwtRefreshCreate(data, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
         * @param {TokenVerify} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthJwtVerifyCreate(data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.accountsAuthJwtVerifyCreate(data, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @param {Activation} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersActivation(data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.accountsAuthUsersActivation(data, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @param {CustomUserCreate} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersCreate(data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.accountsAuthUsersCreate(data, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @param {string} email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersDelete(email, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.accountsAuthUsersDelete(email, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersList(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.accountsAuthUsersList(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersMeDelete(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.accountsAuthUsersMeDelete(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @param {User} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersMePartialUpdate(data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.accountsAuthUsersMePartialUpdate(data, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersMeRead(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.accountsAuthUsersMeRead(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @param {User} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersMeUpdate(data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.accountsAuthUsersMeUpdate(data, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @param {string} email
         * @param {User} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersPartialUpdate(email, data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.accountsAuthUsersPartialUpdate(email, data, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @param {string} email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersRead(email, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.accountsAuthUsersRead(email, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @param {SendEmailReset} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersResendActivation(data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.accountsAuthUsersResendActivation(data, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @param {SendEmailReset} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersResetPassword(data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.accountsAuthUsersResetPassword(data, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @param {PasswordResetConfirm} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersResetPasswordConfirm(data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.accountsAuthUsersResetPasswordConfirm(data, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @param {SendEmailReset} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersResetUsername(data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.accountsAuthUsersResetUsername(data, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @param {UsernameResetConfirm} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersResetUsernameConfirm(data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.accountsAuthUsersResetUsernameConfirm(data, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @param {SetPasswordRetype} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersSetPassword(data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.accountsAuthUsersSetPassword(data, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @param {SetUsername} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersSetUsername(data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.accountsAuthUsersSetUsername(data, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @param {string} email
         * @param {User} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersUpdate(email, data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.accountsAuthUsersUpdate(email, data, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @param {CurrentUser} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsCreate(data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.accountsCreate(data, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this Пользователь.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsDelete(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.accountsDelete(id, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsList(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.accountsList(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsMeList(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.accountsMeList(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this Пользователь.
         * @param {CurrentUser} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsPartialUpdate(id, data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.accountsPartialUpdate(id, data, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this Пользователь.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsRead(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.accountsRead(id, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this Пользователь.
         * @param {CurrentUser} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsUpdate(id, data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.accountsUpdate(id, data, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
/**
 * AccountsApi - factory interface
 * @export
 */
exports.AccountsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.AccountsApiFp(configuration);
    return {
        /**
         * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
         * @param {TokenObtainPair} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthJwtCreateCreate(data, options) {
            return localVarFp.accountsAuthJwtCreateCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
         * @param {TokenRefresh} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthJwtRefreshCreate(data, options) {
            return localVarFp.accountsAuthJwtRefreshCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
         * @param {TokenVerify} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthJwtVerifyCreate(data, options) {
            return localVarFp.accountsAuthJwtVerifyCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {Activation} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersActivation(data, options) {
            return localVarFp.accountsAuthUsersActivation(data, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {CustomUserCreate} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersCreate(data, options) {
            return localVarFp.accountsAuthUsersCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersDelete(email, options) {
            return localVarFp.accountsAuthUsersDelete(email, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersList(options) {
            return localVarFp.accountsAuthUsersList(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersMeDelete(options) {
            return localVarFp.accountsAuthUsersMeDelete(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {User} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersMePartialUpdate(data, options) {
            return localVarFp.accountsAuthUsersMePartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersMeRead(options) {
            return localVarFp.accountsAuthUsersMeRead(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {User} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersMeUpdate(data, options) {
            return localVarFp.accountsAuthUsersMeUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} email
         * @param {User} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersPartialUpdate(email, data, options) {
            return localVarFp.accountsAuthUsersPartialUpdate(email, data, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersRead(email, options) {
            return localVarFp.accountsAuthUsersRead(email, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {SendEmailReset} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersResendActivation(data, options) {
            return localVarFp.accountsAuthUsersResendActivation(data, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {SendEmailReset} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersResetPassword(data, options) {
            return localVarFp.accountsAuthUsersResetPassword(data, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {PasswordResetConfirm} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersResetPasswordConfirm(data, options) {
            return localVarFp.accountsAuthUsersResetPasswordConfirm(data, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {SendEmailReset} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersResetUsername(data, options) {
            return localVarFp.accountsAuthUsersResetUsername(data, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {UsernameResetConfirm} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersResetUsernameConfirm(data, options) {
            return localVarFp.accountsAuthUsersResetUsernameConfirm(data, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {SetPasswordRetype} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersSetPassword(data, options) {
            return localVarFp.accountsAuthUsersSetPassword(data, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {SetUsername} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersSetUsername(data, options) {
            return localVarFp.accountsAuthUsersSetUsername(data, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} email
         * @param {User} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersUpdate(email, data, options) {
            return localVarFp.accountsAuthUsersUpdate(email, data, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {CurrentUser} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsCreate(data, options) {
            return localVarFp.accountsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this Пользователь.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsDelete(id, options) {
            return localVarFp.accountsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsList(options) {
            return localVarFp.accountsList(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsMeList(options) {
            return localVarFp.accountsMeList(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this Пользователь.
         * @param {CurrentUser} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsPartialUpdate(id, data, options) {
            return localVarFp.accountsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this Пользователь.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsRead(id, options) {
            return localVarFp.accountsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this Пользователь.
         * @param {CurrentUser} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsUpdate(id, data, options) {
            return localVarFp.accountsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
class AccountsApi extends base_1.BaseAPI {
    /**
     * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
     * @param {TokenObtainPair} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    accountsAuthJwtCreateCreate(data, options) {
        return exports.AccountsApiFp(this.configuration).accountsAuthJwtCreateCreate(data, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
     * @param {TokenRefresh} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    accountsAuthJwtRefreshCreate(data, options) {
        return exports.AccountsApiFp(this.configuration).accountsAuthJwtRefreshCreate(data, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
     * @param {TokenVerify} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    accountsAuthJwtVerifyCreate(data, options) {
        return exports.AccountsApiFp(this.configuration).accountsAuthJwtVerifyCreate(data, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {Activation} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    accountsAuthUsersActivation(data, options) {
        return exports.AccountsApiFp(this.configuration).accountsAuthUsersActivation(data, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {CustomUserCreate} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    accountsAuthUsersCreate(data, options) {
        return exports.AccountsApiFp(this.configuration).accountsAuthUsersCreate(data, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    accountsAuthUsersDelete(email, options) {
        return exports.AccountsApiFp(this.configuration).accountsAuthUsersDelete(email, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    accountsAuthUsersList(options) {
        return exports.AccountsApiFp(this.configuration).accountsAuthUsersList(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    accountsAuthUsersMeDelete(options) {
        return exports.AccountsApiFp(this.configuration).accountsAuthUsersMeDelete(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {User} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    accountsAuthUsersMePartialUpdate(data, options) {
        return exports.AccountsApiFp(this.configuration).accountsAuthUsersMePartialUpdate(data, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    accountsAuthUsersMeRead(options) {
        return exports.AccountsApiFp(this.configuration).accountsAuthUsersMeRead(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {User} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    accountsAuthUsersMeUpdate(data, options) {
        return exports.AccountsApiFp(this.configuration).accountsAuthUsersMeUpdate(data, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} email
     * @param {User} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    accountsAuthUsersPartialUpdate(email, data, options) {
        return exports.AccountsApiFp(this.configuration).accountsAuthUsersPartialUpdate(email, data, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    accountsAuthUsersRead(email, options) {
        return exports.AccountsApiFp(this.configuration).accountsAuthUsersRead(email, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {SendEmailReset} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    accountsAuthUsersResendActivation(data, options) {
        return exports.AccountsApiFp(this.configuration).accountsAuthUsersResendActivation(data, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {SendEmailReset} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    accountsAuthUsersResetPassword(data, options) {
        return exports.AccountsApiFp(this.configuration).accountsAuthUsersResetPassword(data, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {PasswordResetConfirm} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    accountsAuthUsersResetPasswordConfirm(data, options) {
        return exports.AccountsApiFp(this.configuration).accountsAuthUsersResetPasswordConfirm(data, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {SendEmailReset} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    accountsAuthUsersResetUsername(data, options) {
        return exports.AccountsApiFp(this.configuration).accountsAuthUsersResetUsername(data, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {UsernameResetConfirm} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    accountsAuthUsersResetUsernameConfirm(data, options) {
        return exports.AccountsApiFp(this.configuration).accountsAuthUsersResetUsernameConfirm(data, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {SetPasswordRetype} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    accountsAuthUsersSetPassword(data, options) {
        return exports.AccountsApiFp(this.configuration).accountsAuthUsersSetPassword(data, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {SetUsername} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    accountsAuthUsersSetUsername(data, options) {
        return exports.AccountsApiFp(this.configuration).accountsAuthUsersSetUsername(data, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} email
     * @param {User} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    accountsAuthUsersUpdate(email, data, options) {
        return exports.AccountsApiFp(this.configuration).accountsAuthUsersUpdate(email, data, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {CurrentUser} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    accountsCreate(data, options) {
        return exports.AccountsApiFp(this.configuration).accountsCreate(data, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this Пользователь.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    accountsDelete(id, options) {
        return exports.AccountsApiFp(this.configuration).accountsDelete(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    accountsList(options) {
        return exports.AccountsApiFp(this.configuration).accountsList(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    accountsMeList(options) {
        return exports.AccountsApiFp(this.configuration).accountsMeList(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this Пользователь.
     * @param {CurrentUser} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    accountsPartialUpdate(id, data, options) {
        return exports.AccountsApiFp(this.configuration).accountsPartialUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this Пользователь.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    accountsRead(id, options) {
        return exports.AccountsApiFp(this.configuration).accountsRead(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this Пользователь.
     * @param {CurrentUser} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    accountsUpdate(id, data, options) {
        return exports.AccountsApiFp(this.configuration).accountsUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AccountsApi = AccountsApi;
/**
 * CategoriesApi - axios parameter creator
 * @export
 */
exports.CategoriesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {Category} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesCreate: (data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'data' is not null or undefined
            common_1.assertParamExists('categoriesCreate', 'data', data);
            const localVarPath = `/categories/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(data, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this Категория.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesDelete: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('categoriesDelete', 'id', id);
            const localVarPath = `/categories/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesList: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/categories/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this Категория.
         * @param {Category} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesPartialUpdate: (id, data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('categoriesPartialUpdate', 'id', id);
            // verify required parameter 'data' is not null or undefined
            common_1.assertParamExists('categoriesPartialUpdate', 'data', data);
            const localVarPath = `/categories/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(data, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this Категория.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesRead: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('categoriesRead', 'id', id);
            const localVarPath = `/categories/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this Категория.
         * @param {Category} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesUpdate: (id, data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('categoriesUpdate', 'id', id);
            // verify required parameter 'data' is not null or undefined
            common_1.assertParamExists('categoriesUpdate', 'data', data);
            const localVarPath = `/categories/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(data, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * CategoriesApi - functional programming interface
 * @export
 */
exports.CategoriesApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.CategoriesApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @param {Category} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesCreate(data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.categoriesCreate(data, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this Категория.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesDelete(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.categoriesDelete(id, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesList(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.categoriesList(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this Категория.
         * @param {Category} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesPartialUpdate(id, data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.categoriesPartialUpdate(id, data, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this Категория.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesRead(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.categoriesRead(id, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this Категория.
         * @param {Category} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesUpdate(id, data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.categoriesUpdate(id, data, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
/**
 * CategoriesApi - factory interface
 * @export
 */
exports.CategoriesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.CategoriesApiFp(configuration);
    return {
        /**
         *
         * @param {Category} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesCreate(data, options) {
            return localVarFp.categoriesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this Категория.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesDelete(id, options) {
            return localVarFp.categoriesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesList(options) {
            return localVarFp.categoriesList(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this Категория.
         * @param {Category} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesPartialUpdate(id, data, options) {
            return localVarFp.categoriesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this Категория.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesRead(id, options) {
            return localVarFp.categoriesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this Категория.
         * @param {Category} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesUpdate(id, data, options) {
            return localVarFp.categoriesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * CategoriesApi - object-oriented interface
 * @export
 * @class CategoriesApi
 * @extends {BaseAPI}
 */
class CategoriesApi extends base_1.BaseAPI {
    /**
     *
     * @param {Category} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    categoriesCreate(data, options) {
        return exports.CategoriesApiFp(this.configuration).categoriesCreate(data, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this Категория.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    categoriesDelete(id, options) {
        return exports.CategoriesApiFp(this.configuration).categoriesDelete(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    categoriesList(options) {
        return exports.CategoriesApiFp(this.configuration).categoriesList(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this Категория.
     * @param {Category} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    categoriesPartialUpdate(id, data, options) {
        return exports.CategoriesApiFp(this.configuration).categoriesPartialUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this Категория.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    categoriesRead(id, options) {
        return exports.CategoriesApiFp(this.configuration).categoriesRead(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this Категория.
     * @param {Category} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    categoriesUpdate(id, data, options) {
        return exports.CategoriesApiFp(this.configuration).categoriesUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.CategoriesApi = CategoriesApi;
/**
 * ExamsApi - axios parameter creator
 * @export
 */
exports.ExamsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {Exam} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsExamsCreate: (data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'data' is not null or undefined
            common_1.assertParamExists('examsExamsCreate', 'data', data);
            const localVarPath = `/exams/exams/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(data, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this Экзамен.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsExamsDelete: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('examsExamsDelete', 'id', id);
            const localVarPath = `/exams/exams/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsExamsList: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/exams/exams/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this Экзамен.
         * @param {Exam} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsExamsPartialUpdate: (id, data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('examsExamsPartialUpdate', 'id', id);
            // verify required parameter 'data' is not null or undefined
            common_1.assertParamExists('examsExamsPartialUpdate', 'data', data);
            const localVarPath = `/exams/exams/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(data, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this Экзамен.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsExamsRead: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('examsExamsRead', 'id', id);
            const localVarPath = `/exams/exams/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this Экзамен.
         * @param {Exam} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsExamsUpdate: (id, data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('examsExamsUpdate', 'id', id);
            // verify required parameter 'data' is not null or undefined
            common_1.assertParamExists('examsExamsUpdate', 'data', data);
            const localVarPath = `/exams/exams/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(data, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this ВОПРОС.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsQuestionsDelete: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('examsQuestionsDelete', 'id', id);
            const localVarPath = `/exams/questions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {UserExam} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsUserExamsCreate: (data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'data' is not null or undefined
            common_1.assertParamExists('examsUserExamsCreate', 'data', data);
            const localVarPath = `/exams/user-exams/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(data, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this ПОЛЬЗОВАТЕЛЬСКИЙ ЭКЗАМЕН.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsUserExamsDelete: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('examsUserExamsDelete', 'id', id);
            const localVarPath = `/exams/user-exams/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsUserExamsList: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/exams/user-exams/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this ПОЛЬЗОВАТЕЛЬСКИЙ ЭКЗАМЕН.
         * @param {UserExam} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsUserExamsPartialUpdate: (id, data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('examsUserExamsPartialUpdate', 'id', id);
            // verify required parameter 'data' is not null or undefined
            common_1.assertParamExists('examsUserExamsPartialUpdate', 'data', data);
            const localVarPath = `/exams/user-exams/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(data, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this ПОЛЬЗОВАТЕЛЬСКИЙ ЭКЗАМЕН.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsUserExamsRead: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('examsUserExamsRead', 'id', id);
            const localVarPath = `/exams/user-exams/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this ПОЛЬЗОВАТЕЛЬСКИЙ ЭКЗАМЕН.
         * @param {UserExam} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsUserExamsUpdate: (id, data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('examsUserExamsUpdate', 'id', id);
            // verify required parameter 'data' is not null or undefined
            common_1.assertParamExists('examsUserExamsUpdate', 'data', data);
            const localVarPath = `/exams/user-exams/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(data, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ExamsApi - functional programming interface
 * @export
 */
exports.ExamsApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.ExamsApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @param {Exam} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsExamsCreate(data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.examsExamsCreate(data, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this Экзамен.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsExamsDelete(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.examsExamsDelete(id, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsExamsList(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.examsExamsList(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this Экзамен.
         * @param {Exam} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsExamsPartialUpdate(id, data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.examsExamsPartialUpdate(id, data, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this Экзамен.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsExamsRead(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.examsExamsRead(id, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this Экзамен.
         * @param {Exam} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsExamsUpdate(id, data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.examsExamsUpdate(id, data, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this ВОПРОС.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsQuestionsDelete(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.examsQuestionsDelete(id, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @param {UserExam} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsUserExamsCreate(data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.examsUserExamsCreate(data, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this ПОЛЬЗОВАТЕЛЬСКИЙ ЭКЗАМЕН.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsUserExamsDelete(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.examsUserExamsDelete(id, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsUserExamsList(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.examsUserExamsList(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this ПОЛЬЗОВАТЕЛЬСКИЙ ЭКЗАМЕН.
         * @param {UserExam} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsUserExamsPartialUpdate(id, data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.examsUserExamsPartialUpdate(id, data, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this ПОЛЬЗОВАТЕЛЬСКИЙ ЭКЗАМЕН.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsUserExamsRead(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.examsUserExamsRead(id, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this ПОЛЬЗОВАТЕЛЬСКИЙ ЭКЗАМЕН.
         * @param {UserExam} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsUserExamsUpdate(id, data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.examsUserExamsUpdate(id, data, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
/**
 * ExamsApi - factory interface
 * @export
 */
exports.ExamsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.ExamsApiFp(configuration);
    return {
        /**
         *
         * @param {Exam} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsExamsCreate(data, options) {
            return localVarFp.examsExamsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this Экзамен.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsExamsDelete(id, options) {
            return localVarFp.examsExamsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsExamsList(options) {
            return localVarFp.examsExamsList(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this Экзамен.
         * @param {Exam} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsExamsPartialUpdate(id, data, options) {
            return localVarFp.examsExamsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this Экзамен.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsExamsRead(id, options) {
            return localVarFp.examsExamsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this Экзамен.
         * @param {Exam} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsExamsUpdate(id, data, options) {
            return localVarFp.examsExamsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this ВОПРОС.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsQuestionsDelete(id, options) {
            return localVarFp.examsQuestionsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {UserExam} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsUserExamsCreate(data, options) {
            return localVarFp.examsUserExamsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this ПОЛЬЗОВАТЕЛЬСКИЙ ЭКЗАМЕН.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsUserExamsDelete(id, options) {
            return localVarFp.examsUserExamsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsUserExamsList(options) {
            return localVarFp.examsUserExamsList(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this ПОЛЬЗОВАТЕЛЬСКИЙ ЭКЗАМЕН.
         * @param {UserExam} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsUserExamsPartialUpdate(id, data, options) {
            return localVarFp.examsUserExamsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this ПОЛЬЗОВАТЕЛЬСКИЙ ЭКЗАМЕН.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsUserExamsRead(id, options) {
            return localVarFp.examsUserExamsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this ПОЛЬЗОВАТЕЛЬСКИЙ ЭКЗАМЕН.
         * @param {UserExam} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsUserExamsUpdate(id, data, options) {
            return localVarFp.examsUserExamsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ExamsApi - object-oriented interface
 * @export
 * @class ExamsApi
 * @extends {BaseAPI}
 */
class ExamsApi extends base_1.BaseAPI {
    /**
     *
     * @param {Exam} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamsApi
     */
    examsExamsCreate(data, options) {
        return exports.ExamsApiFp(this.configuration).examsExamsCreate(data, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this Экзамен.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamsApi
     */
    examsExamsDelete(id, options) {
        return exports.ExamsApiFp(this.configuration).examsExamsDelete(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamsApi
     */
    examsExamsList(options) {
        return exports.ExamsApiFp(this.configuration).examsExamsList(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this Экзамен.
     * @param {Exam} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamsApi
     */
    examsExamsPartialUpdate(id, data, options) {
        return exports.ExamsApiFp(this.configuration).examsExamsPartialUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this Экзамен.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamsApi
     */
    examsExamsRead(id, options) {
        return exports.ExamsApiFp(this.configuration).examsExamsRead(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this Экзамен.
     * @param {Exam} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamsApi
     */
    examsExamsUpdate(id, data, options) {
        return exports.ExamsApiFp(this.configuration).examsExamsUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this ВОПРОС.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamsApi
     */
    examsQuestionsDelete(id, options) {
        return exports.ExamsApiFp(this.configuration).examsQuestionsDelete(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {UserExam} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamsApi
     */
    examsUserExamsCreate(data, options) {
        return exports.ExamsApiFp(this.configuration).examsUserExamsCreate(data, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this ПОЛЬЗОВАТЕЛЬСКИЙ ЭКЗАМЕН.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamsApi
     */
    examsUserExamsDelete(id, options) {
        return exports.ExamsApiFp(this.configuration).examsUserExamsDelete(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamsApi
     */
    examsUserExamsList(options) {
        return exports.ExamsApiFp(this.configuration).examsUserExamsList(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this ПОЛЬЗОВАТЕЛЬСКИЙ ЭКЗАМЕН.
     * @param {UserExam} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamsApi
     */
    examsUserExamsPartialUpdate(id, data, options) {
        return exports.ExamsApiFp(this.configuration).examsUserExamsPartialUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this ПОЛЬЗОВАТЕЛЬСКИЙ ЭКЗАМЕН.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamsApi
     */
    examsUserExamsRead(id, options) {
        return exports.ExamsApiFp(this.configuration).examsUserExamsRead(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this ПОЛЬЗОВАТЕЛЬСКИЙ ЭКЗАМЕН.
     * @param {UserExam} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamsApi
     */
    examsUserExamsUpdate(id, data, options) {
        return exports.ExamsApiFp(this.configuration).examsUserExamsUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ExamsApi = ExamsApi;
