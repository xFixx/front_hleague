/* tslint:disable */
/* eslint-disable */
/**
 * Hero League API
 * Test description
 *
 * The version of the OpenAPI document: v1
 * Contact: contact@jva.local
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Activation
 */
export interface Activation {
    /**
     * 
     * @type {string}
     * @memberof Activation
     */
    'uid': string;
    /**
     * 
     * @type {string}
     * @memberof Activation
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface Category
 */
export interface Category {
    /**
     * 
     * @type {number}
     * @memberof Category
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'title': string;
    /**
     * 
     * @type {Array<Exam>}
     * @memberof Category
     */
    'exams'?: Array<Exam>;
}
/**
 * 
 * @export
 * @interface CurrentUser
 */
export interface CurrentUser {
    /**
     * 
     * @type {number}
     * @memberof CurrentUser
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof CurrentUser
     */
    'avatar'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CurrentUser
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof CurrentUser
     */
    'first_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CurrentUser
     */
    'last_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CurrentUser
     */
    'phone_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CurrentUser
     */
    'date_birthday'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CurrentUser
     */
    'role'?: CurrentUserRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof CurrentUser
     */
    'city'?: string | null;
}

export const CurrentUserRoleEnum = {
    Instructor: 'Instructor',
    Volunteer: 'Volunteer',
    Judge: 'Judge',
    Trainer: 'Trainer'
} as const;

export type CurrentUserRoleEnum = typeof CurrentUserRoleEnum[keyof typeof CurrentUserRoleEnum];

/**
 * 
 * @export
 * @interface CustomUserCreate
 */
export interface CustomUserCreate {
    /**
     * 
     * @type {string}
     * @memberof CustomUserCreate
     */
    'avatar'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CustomUserCreate
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof CustomUserCreate
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof CustomUserCreate
     */
    'first_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CustomUserCreate
     */
    'last_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CustomUserCreate
     */
    'phone_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CustomUserCreate
     */
    'date_birthday'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CustomUserCreate
     */
    'role'?: CustomUserCreateRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof CustomUserCreate
     */
    'city'?: string | null;
}

export const CustomUserCreateRoleEnum = {
    Instructor: 'Instructor',
    Volunteer: 'Volunteer',
    Judge: 'Judge',
    Trainer: 'Trainer'
} as const;

export type CustomUserCreateRoleEnum = typeof CustomUserCreateRoleEnum[keyof typeof CustomUserCreateRoleEnum];

/**
 * 
 * @export
 * @interface Exam
 */
export interface Exam {
    /**
     * 
     * @type {number}
     * @memberof Exam
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Exam
     */
    'title': string;
    /**
     * 
     * @type {Array<ExamQuestion>}
     * @memberof Exam
     */
    'questions': Array<ExamQuestion> | null;
}
/**
 * 
 * @export
 * @interface ExamQuestion
 */
export interface ExamQuestion {
    /**
     * 
     * @type {number}
     * @memberof ExamQuestion
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExamQuestion
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ExamQuestion
     */
    'question_type': ExamQuestionQuestionTypeEnum;
    /**
     * 
     * @type {Array<QuestionAnswer>}
     * @memberof ExamQuestion
     */
    'answers'?: Array<QuestionAnswer>;
    /**
     * 
     * @type {string}
     * @memberof ExamQuestion
     */
    'attachment_file'?: string | null;
}

export const ExamQuestionQuestionTypeEnum = {
    R: 'R',
    C: 'C'
} as const;

export type ExamQuestionQuestionTypeEnum = typeof ExamQuestionQuestionTypeEnum[keyof typeof ExamQuestionQuestionTypeEnum];

/**
 * 
 * @export
 * @interface PasswordResetConfirm
 */
export interface PasswordResetConfirm {
    /**
     * 
     * @type {string}
     * @memberof PasswordResetConfirm
     */
    'uid': string;
    /**
     * 
     * @type {string}
     * @memberof PasswordResetConfirm
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof PasswordResetConfirm
     */
    'new_password': string;
}
/**
 * 
 * @export
 * @interface QuestionAnswer
 */
export interface QuestionAnswer {
    /**
     * 
     * @type {number}
     * @memberof QuestionAnswer
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof QuestionAnswer
     */
    'title'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof QuestionAnswer
     */
    'is_correct'?: boolean;
}
/**
 * 
 * @export
 * @interface SendEmailReset
 */
export interface SendEmailReset {
    /**
     * 
     * @type {string}
     * @memberof SendEmailReset
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface SetPasswordRetype
 */
export interface SetPasswordRetype {
    /**
     * 
     * @type {string}
     * @memberof SetPasswordRetype
     */
    'new_password': string;
    /**
     * 
     * @type {string}
     * @memberof SetPasswordRetype
     */
    're_new_password': string;
    /**
     * 
     * @type {string}
     * @memberof SetPasswordRetype
     */
    'current_password': string;
}
/**
 * 
 * @export
 * @interface SetUsername
 */
export interface SetUsername {
    /**
     * 
     * @type {string}
     * @memberof SetUsername
     */
    'current_password': string;
    /**
     * 
     * @type {string}
     * @memberof SetUsername
     */
    'new_email': string;
}
/**
 * 
 * @export
 * @interface TokenObtainPair
 */
export interface TokenObtainPair {
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPair
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPair
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface TokenRefresh
 */
export interface TokenRefresh {
    /**
     * 
     * @type {string}
     * @memberof TokenRefresh
     */
    'refresh': string;
    /**
     * 
     * @type {string}
     * @memberof TokenRefresh
     */
    'access'?: string;
}
/**
 * 
 * @export
 * @interface TokenVerify
 */
export interface TokenVerify {
    /**
     * 
     * @type {string}
     * @memberof TokenVerify
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface UserAnswer
 */
export interface UserAnswer {
    /**
     * 
     * @type {number}
     * @memberof UserAnswer
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserAnswer
     */
    'question': number;
    /**
     * 
     * @type {number}
     * @memberof UserAnswer
     */
    'answer'?: number | null;
    /**
     * 
     * @type {Array<UserCheckBoxAnswer>}
     * @memberof UserAnswer
     */
    'check_boxes'?: Array<UserCheckBoxAnswer>;
    /**
     * 
     * @type {boolean}
     * @memberof UserAnswer
     */
    'is_correct'?: boolean;
}
/**
 * 
 * @export
 * @interface UserAnswersDetail
 */
export interface UserAnswersDetail {
    /**
     * 
     * @type {number}
     * @memberof UserAnswersDetail
     */
    'id'?: number;
    /**
     * 
     * @type {ExamQuestion}
     * @memberof UserAnswersDetail
     */
    'question': ExamQuestion | null;
    /**
     * 
     * @type {QuestionAnswer}
     * @memberof UserAnswersDetail
     */
    'answer': QuestionAnswer;
    /**
     * 
     * @type {Array<UserDetailCheckBoxAnswer>}
     * @memberof UserAnswersDetail
     */
    'check_boxes'?: Array<UserDetailCheckBoxAnswer>;
    /**
     * 
     * @type {boolean}
     * @memberof UserAnswersDetail
     */
    'is_correct'?: boolean;
}
/**
 * 
 * @export
 * @interface UserCheckBoxAnswer
 */
export interface UserCheckBoxAnswer {
    /**
     * 
     * @type {number}
     * @memberof UserCheckBoxAnswer
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserCheckBoxAnswer
     */
    'answer': number;
}
/**
 * 
 * @export
 * @interface UserDetail
 */
export interface UserDetail {
    /**
     * 
     * @type {string}
     * @memberof UserDetail
     */
    'first_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserDetail
     */
    'last_name'?: string | null;
}
/**
 * 
 * @export
 * @interface UserDetailCheckBoxAnswer
 */
export interface UserDetailCheckBoxAnswer {
    /**
     * 
     * @type {number}
     * @memberof UserDetailCheckBoxAnswer
     */
    'id'?: number;
    /**
     * 
     * @type {QuestionAnswer}
     * @memberof UserDetailCheckBoxAnswer
     */
    'answer': QuestionAnswer;
}
/**
 * 
 * @export
 * @interface UserExam
 */
export interface UserExam {
    /**
     * 
     * @type {number}
     * @memberof UserExam
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserExam
     */
    'exam'?: number | null;
    /**
     * 
     * @type {Array<UserAnswer>}
     * @memberof UserExam
     */
    'user_answers': Array<UserAnswer>;
    /**
     * 
     * @type {boolean}
     * @memberof UserExam
     */
    'passed'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserExam
     */
    'statistic'?: string;
}
/**
 * 
 * @export
 * @interface UserExamDetail
 */
export interface UserExamDetail {
    /**
     * 
     * @type {number}
     * @memberof UserExamDetail
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UserExamDetail
     */
    'passed'?: boolean;
    /**
     * 
     * @type {UserDetail}
     * @memberof UserExamDetail
     */
    'user': UserDetail;
    /**
     * 
     * @type {Array<UserAnswersDetail>}
     * @memberof UserExamDetail
     */
    'user_answers': Array<UserAnswersDetail>;
    /**
     * 
     * @type {string}
     * @memberof UserExamDetail
     */
    'statistic'?: string;
}
/**
 * 
 * @export
 * @interface UsernameResetConfirm
 */
export interface UsernameResetConfirm {
    /**
     * 
     * @type {string}
     * @memberof UsernameResetConfirm
     */
    'new_email': string;
}

/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
         * @param {TokenObtainPair} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthJwtCreateCreate: async (data: TokenObtainPair, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('accountsAuthJwtCreateCreate', 'data', data)
            const localVarPath = `/accounts/auth/jwt/create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
         * @param {TokenRefresh} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthJwtRefreshCreate: async (data: TokenRefresh, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('accountsAuthJwtRefreshCreate', 'data', data)
            const localVarPath = `/accounts/auth/jwt/refresh/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
         * @param {TokenVerify} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthJwtVerifyCreate: async (data: TokenVerify, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('accountsAuthJwtVerifyCreate', 'data', data)
            const localVarPath = `/accounts/auth/jwt/verify/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Activation} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersActivation: async (data: Activation, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('accountsAuthUsersActivation', 'data', data)
            const localVarPath = `/accounts/auth/users/activation/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CustomUserCreate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersCreate: async (data: CustomUserCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('accountsAuthUsersCreate', 'data', data)
            const localVarPath = `/accounts/auth/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersDelete: async (email: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('accountsAuthUsersDelete', 'email', email)
            const localVarPath = `/accounts/auth/users/{email}/`
                .replace(`{${"email"}}`, encodeURIComponent(String(email)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts/auth/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersMeDelete: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts/auth/users/me/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {User} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersMePartialUpdate: async (data: User, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('accountsAuthUsersMePartialUpdate', 'data', data)
            const localVarPath = `/accounts/auth/users/me/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersMeRead: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts/auth/users/me/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {User} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersMeUpdate: async (data: User, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('accountsAuthUsersMeUpdate', 'data', data)
            const localVarPath = `/accounts/auth/users/me/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} email 
         * @param {User} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersPartialUpdate: async (email: string, data: User, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('accountsAuthUsersPartialUpdate', 'email', email)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('accountsAuthUsersPartialUpdate', 'data', data)
            const localVarPath = `/accounts/auth/users/{email}/`
                .replace(`{${"email"}}`, encodeURIComponent(String(email)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersRead: async (email: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('accountsAuthUsersRead', 'email', email)
            const localVarPath = `/accounts/auth/users/{email}/`
                .replace(`{${"email"}}`, encodeURIComponent(String(email)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SendEmailReset} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersResendActivation: async (data: SendEmailReset, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('accountsAuthUsersResendActivation', 'data', data)
            const localVarPath = `/accounts/auth/users/resend_activation/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SendEmailReset} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersResetPassword: async (data: SendEmailReset, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('accountsAuthUsersResetPassword', 'data', data)
            const localVarPath = `/accounts/auth/users/reset_password/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PasswordResetConfirm} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersResetPasswordConfirm: async (data: PasswordResetConfirm, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('accountsAuthUsersResetPasswordConfirm', 'data', data)
            const localVarPath = `/accounts/auth/users/reset_password_confirm/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SendEmailReset} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersResetUsername: async (data: SendEmailReset, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('accountsAuthUsersResetUsername', 'data', data)
            const localVarPath = `/accounts/auth/users/reset_email/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UsernameResetConfirm} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersResetUsernameConfirm: async (data: UsernameResetConfirm, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('accountsAuthUsersResetUsernameConfirm', 'data', data)
            const localVarPath = `/accounts/auth/users/reset_email_confirm/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SetPasswordRetype} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersSetPassword: async (data: SetPasswordRetype, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('accountsAuthUsersSetPassword', 'data', data)
            const localVarPath = `/accounts/auth/users/set_password/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SetUsername} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersSetUsername: async (data: SetUsername, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('accountsAuthUsersSetUsername', 'data', data)
            const localVarPath = `/accounts/auth/users/set_email/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} email 
         * @param {User} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersUpdate: async (email: string, data: User, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('accountsAuthUsersUpdate', 'email', email)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('accountsAuthUsersUpdate', 'data', data)
            const localVarPath = `/accounts/auth/users/{email}/`
                .replace(`{${"email"}}`, encodeURIComponent(String(email)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CurrentUser} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsCreate: async (data: CurrentUser, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('accountsCreate', 'data', data)
            const localVarPath = `/accounts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Пользователь.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountsDelete', 'id', id)
            const localVarPath = `/accounts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsMeList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts/me/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Пользователь.
         * @param {CurrentUser} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsPartialUpdate: async (id: number, data: CurrentUser, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('accountsPartialUpdate', 'data', data)
            const localVarPath = `/accounts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Пользователь.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsRead: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountsRead', 'id', id)
            const localVarPath = `/accounts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Пользователь.
         * @param {CurrentUser} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsUpdate: async (id: number, data: CurrentUser, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('accountsUpdate', 'data', data)
            const localVarPath = `/accounts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
         * @param {TokenObtainPair} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAuthJwtCreateCreate(data: TokenObtainPair, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenObtainPair>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAuthJwtCreateCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
         * @param {TokenRefresh} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAuthJwtRefreshCreate(data: TokenRefresh, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenRefresh>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAuthJwtRefreshCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
         * @param {TokenVerify} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAuthJwtVerifyCreate(data: TokenVerify, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenVerify>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAuthJwtVerifyCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Activation} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAuthUsersActivation(data: Activation, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Activation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAuthUsersActivation(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CustomUserCreate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAuthUsersCreate(data: CustomUserCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomUserCreate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAuthUsersCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAuthUsersDelete(email: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAuthUsersDelete(email, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAuthUsersList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAuthUsersList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAuthUsersMeDelete(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAuthUsersMeDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {User} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAuthUsersMePartialUpdate(data: User, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAuthUsersMePartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAuthUsersMeRead(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAuthUsersMeRead(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {User} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAuthUsersMeUpdate(data: User, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAuthUsersMeUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} email 
         * @param {User} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAuthUsersPartialUpdate(email: string, data: User, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAuthUsersPartialUpdate(email, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAuthUsersRead(email: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAuthUsersRead(email, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SendEmailReset} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAuthUsersResendActivation(data: SendEmailReset, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SendEmailReset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAuthUsersResendActivation(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SendEmailReset} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAuthUsersResetPassword(data: SendEmailReset, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SendEmailReset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAuthUsersResetPassword(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {PasswordResetConfirm} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAuthUsersResetPasswordConfirm(data: PasswordResetConfirm, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordResetConfirm>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAuthUsersResetPasswordConfirm(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SendEmailReset} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAuthUsersResetUsername(data: SendEmailReset, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SendEmailReset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAuthUsersResetUsername(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UsernameResetConfirm} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAuthUsersResetUsernameConfirm(data: UsernameResetConfirm, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsernameResetConfirm>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAuthUsersResetUsernameConfirm(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SetPasswordRetype} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAuthUsersSetPassword(data: SetPasswordRetype, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetPasswordRetype>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAuthUsersSetPassword(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SetUsername} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAuthUsersSetUsername(data: SetUsername, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetUsername>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAuthUsersSetUsername(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} email 
         * @param {User} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAuthUsersUpdate(email: string, data: User, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAuthUsersUpdate(email, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CurrentUser} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsCreate(data: CurrentUser, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrentUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Пользователь.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CurrentUser>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsMeList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsMeList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Пользователь.
         * @param {CurrentUser} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsPartialUpdate(id: number, data: CurrentUser, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrentUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Пользователь.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsRead(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrentUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Пользователь.
         * @param {CurrentUser} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsUpdate(id: number, data: CurrentUser, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrentUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
         * @param {TokenObtainPair} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthJwtCreateCreate(data: TokenObtainPair, options?: any): AxiosPromise<TokenObtainPair> {
            return localVarFp.accountsAuthJwtCreateCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
         * @param {TokenRefresh} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthJwtRefreshCreate(data: TokenRefresh, options?: any): AxiosPromise<TokenRefresh> {
            return localVarFp.accountsAuthJwtRefreshCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
         * @param {TokenVerify} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthJwtVerifyCreate(data: TokenVerify, options?: any): AxiosPromise<TokenVerify> {
            return localVarFp.accountsAuthJwtVerifyCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Activation} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersActivation(data: Activation, options?: any): AxiosPromise<Activation> {
            return localVarFp.accountsAuthUsersActivation(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CustomUserCreate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersCreate(data: CustomUserCreate, options?: any): AxiosPromise<CustomUserCreate> {
            return localVarFp.accountsAuthUsersCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersDelete(email: string, options?: any): AxiosPromise<void> {
            return localVarFp.accountsAuthUsersDelete(email, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersList(options?: any): AxiosPromise<Array<User>> {
            return localVarFp.accountsAuthUsersList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersMeDelete(options?: any): AxiosPromise<void> {
            return localVarFp.accountsAuthUsersMeDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {User} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersMePartialUpdate(data: User, options?: any): AxiosPromise<User> {
            return localVarFp.accountsAuthUsersMePartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersMeRead(options?: any): AxiosPromise<Array<User>> {
            return localVarFp.accountsAuthUsersMeRead(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {User} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersMeUpdate(data: User, options?: any): AxiosPromise<User> {
            return localVarFp.accountsAuthUsersMeUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} email 
         * @param {User} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersPartialUpdate(email: string, data: User, options?: any): AxiosPromise<User> {
            return localVarFp.accountsAuthUsersPartialUpdate(email, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersRead(email: string, options?: any): AxiosPromise<User> {
            return localVarFp.accountsAuthUsersRead(email, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SendEmailReset} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersResendActivation(data: SendEmailReset, options?: any): AxiosPromise<SendEmailReset> {
            return localVarFp.accountsAuthUsersResendActivation(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SendEmailReset} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersResetPassword(data: SendEmailReset, options?: any): AxiosPromise<SendEmailReset> {
            return localVarFp.accountsAuthUsersResetPassword(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PasswordResetConfirm} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersResetPasswordConfirm(data: PasswordResetConfirm, options?: any): AxiosPromise<PasswordResetConfirm> {
            return localVarFp.accountsAuthUsersResetPasswordConfirm(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SendEmailReset} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersResetUsername(data: SendEmailReset, options?: any): AxiosPromise<SendEmailReset> {
            return localVarFp.accountsAuthUsersResetUsername(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UsernameResetConfirm} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersResetUsernameConfirm(data: UsernameResetConfirm, options?: any): AxiosPromise<UsernameResetConfirm> {
            return localVarFp.accountsAuthUsersResetUsernameConfirm(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SetPasswordRetype} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersSetPassword(data: SetPasswordRetype, options?: any): AxiosPromise<SetPasswordRetype> {
            return localVarFp.accountsAuthUsersSetPassword(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SetUsername} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersSetUsername(data: SetUsername, options?: any): AxiosPromise<SetUsername> {
            return localVarFp.accountsAuthUsersSetUsername(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} email 
         * @param {User} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAuthUsersUpdate(email: string, data: User, options?: any): AxiosPromise<User> {
            return localVarFp.accountsAuthUsersUpdate(email, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CurrentUser} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsCreate(data: CurrentUser, options?: any): AxiosPromise<CurrentUser> {
            return localVarFp.accountsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Пользователь.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.accountsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsList(options?: any): AxiosPromise<Array<CurrentUser>> {
            return localVarFp.accountsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsMeList(options?: any): AxiosPromise<void> {
            return localVarFp.accountsMeList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Пользователь.
         * @param {CurrentUser} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsPartialUpdate(id: number, data: CurrentUser, options?: any): AxiosPromise<CurrentUser> {
            return localVarFp.accountsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Пользователь.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsRead(id: number, options?: any): AxiosPromise<CurrentUser> {
            return localVarFp.accountsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Пользователь.
         * @param {CurrentUser} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsUpdate(id: number, data: CurrentUser, options?: any): AxiosPromise<CurrentUser> {
            return localVarFp.accountsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
     * @param {TokenObtainPair} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsAuthJwtCreateCreate(data: TokenObtainPair, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsAuthJwtCreateCreate(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
     * @param {TokenRefresh} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsAuthJwtRefreshCreate(data: TokenRefresh, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsAuthJwtRefreshCreate(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
     * @param {TokenVerify} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsAuthJwtVerifyCreate(data: TokenVerify, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsAuthJwtVerifyCreate(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Activation} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsAuthUsersActivation(data: Activation, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsAuthUsersActivation(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CustomUserCreate} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsAuthUsersCreate(data: CustomUserCreate, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsAuthUsersCreate(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} email 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsAuthUsersDelete(email: string, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsAuthUsersDelete(email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsAuthUsersList(options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsAuthUsersList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsAuthUsersMeDelete(options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsAuthUsersMeDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {User} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsAuthUsersMePartialUpdate(data: User, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsAuthUsersMePartialUpdate(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsAuthUsersMeRead(options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsAuthUsersMeRead(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {User} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsAuthUsersMeUpdate(data: User, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsAuthUsersMeUpdate(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} email 
     * @param {User} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsAuthUsersPartialUpdate(email: string, data: User, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsAuthUsersPartialUpdate(email, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} email 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsAuthUsersRead(email: string, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsAuthUsersRead(email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SendEmailReset} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsAuthUsersResendActivation(data: SendEmailReset, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsAuthUsersResendActivation(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SendEmailReset} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsAuthUsersResetPassword(data: SendEmailReset, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsAuthUsersResetPassword(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PasswordResetConfirm} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsAuthUsersResetPasswordConfirm(data: PasswordResetConfirm, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsAuthUsersResetPasswordConfirm(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SendEmailReset} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsAuthUsersResetUsername(data: SendEmailReset, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsAuthUsersResetUsername(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsernameResetConfirm} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsAuthUsersResetUsernameConfirm(data: UsernameResetConfirm, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsAuthUsersResetUsernameConfirm(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SetPasswordRetype} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsAuthUsersSetPassword(data: SetPasswordRetype, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsAuthUsersSetPassword(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SetUsername} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsAuthUsersSetUsername(data: SetUsername, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsAuthUsersSetUsername(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} email 
     * @param {User} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsAuthUsersUpdate(email: string, data: User, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsAuthUsersUpdate(email, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CurrentUser} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsCreate(data: CurrentUser, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsCreate(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Пользователь.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsDelete(id: number, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsList(options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsMeList(options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsMeList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Пользователь.
     * @param {CurrentUser} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsPartialUpdate(id: number, data: CurrentUser, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsPartialUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Пользователь.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsRead(id: number, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsRead(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Пользователь.
     * @param {CurrentUser} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsUpdate(id: number, data: CurrentUser, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CategoriesApi - axios parameter creator
 * @export
 */
export const CategoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Category} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesCreate: async (data: Category, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('categoriesCreate', 'data', data)
            const localVarPath = `/categories/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Категория.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('categoriesDelete', 'id', id)
            const localVarPath = `/categories/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/categories/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Категория.
         * @param {Category} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesPartialUpdate: async (id: number, data: Category, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('categoriesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('categoriesPartialUpdate', 'data', data)
            const localVarPath = `/categories/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Категория.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesRead: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('categoriesRead', 'id', id)
            const localVarPath = `/categories/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Категория.
         * @param {Category} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesUpdate: async (id: number, data: Category, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('categoriesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('categoriesUpdate', 'data', data)
            const localVarPath = `/categories/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoriesApi - functional programming interface
 * @export
 */
export const CategoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CategoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Category} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoriesCreate(data: Category, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoriesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Категория.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoriesDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoriesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoriesList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Category>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoriesList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Категория.
         * @param {Category} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoriesPartialUpdate(id: number, data: Category, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoriesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Категория.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoriesRead(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoriesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Категория.
         * @param {Category} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoriesUpdate(id: number, data: Category, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoriesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CategoriesApi - factory interface
 * @export
 */
export const CategoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CategoriesApiFp(configuration)
    return {
        /**
         * 
         * @param {Category} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesCreate(data: Category, options?: any): AxiosPromise<Category> {
            return localVarFp.categoriesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Категория.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.categoriesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesList(options?: any): AxiosPromise<Array<Category>> {
            return localVarFp.categoriesList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Категория.
         * @param {Category} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesPartialUpdate(id: number, data: Category, options?: any): AxiosPromise<Category> {
            return localVarFp.categoriesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Категория.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesRead(id: number, options?: any): AxiosPromise<Category> {
            return localVarFp.categoriesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Категория.
         * @param {Category} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesUpdate(id: number, data: Category, options?: any): AxiosPromise<Category> {
            return localVarFp.categoriesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CategoriesApi - object-oriented interface
 * @export
 * @class CategoriesApi
 * @extends {BaseAPI}
 */
export class CategoriesApi extends BaseAPI {
    /**
     * 
     * @param {Category} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public categoriesCreate(data: Category, options?: AxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).categoriesCreate(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Категория.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public categoriesDelete(id: number, options?: AxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).categoriesDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public categoriesList(options?: AxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).categoriesList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Категория.
     * @param {Category} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public categoriesPartialUpdate(id: number, data: Category, options?: AxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).categoriesPartialUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Категория.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public categoriesRead(id: number, options?: AxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).categoriesRead(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Категория.
     * @param {Category} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public categoriesUpdate(id: number, data: Category, options?: AxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).categoriesUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ExamsApi - axios parameter creator
 * @export
 */
export const ExamsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Exam} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsExamsCreate: async (data: Exam, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('examsExamsCreate', 'data', data)
            const localVarPath = `/exams/exams/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Экзамен.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsExamsDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('examsExamsDelete', 'id', id)
            const localVarPath = `/exams/exams/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsExamsList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/exams/exams/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Экзамен.
         * @param {Exam} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsExamsPartialUpdate: async (id: number, data: Exam, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('examsExamsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('examsExamsPartialUpdate', 'data', data)
            const localVarPath = `/exams/exams/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Экзамен.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsExamsRead: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('examsExamsRead', 'id', id)
            const localVarPath = `/exams/exams/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Экзамен.
         * @param {Exam} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsExamsUpdate: async (id: number, data: Exam, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('examsExamsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('examsExamsUpdate', 'data', data)
            const localVarPath = `/exams/exams/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ВОПРОС.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsQuestionsDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('examsQuestionsDelete', 'id', id)
            const localVarPath = `/exams/questions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserExam} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsUserExamsCreate: async (data: UserExam, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('examsUserExamsCreate', 'data', data)
            const localVarPath = `/exams/user-exams/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ПОЛЬЗОВАТЕЛЬСКИЙ ЭКЗАМЕН.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsUserExamsDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('examsUserExamsDelete', 'id', id)
            const localVarPath = `/exams/user-exams/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsUserExamsList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/exams/user-exams/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ПОЛЬЗОВАТЕЛЬСКИЙ ЭКЗАМЕН.
         * @param {UserExam} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsUserExamsPartialUpdate: async (id: number, data: UserExam, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('examsUserExamsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('examsUserExamsPartialUpdate', 'data', data)
            const localVarPath = `/exams/user-exams/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ПОЛЬЗОВАТЕЛЬСКИЙ ЭКЗАМЕН.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsUserExamsRead: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('examsUserExamsRead', 'id', id)
            const localVarPath = `/exams/user-exams/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ПОЛЬЗОВАТЕЛЬСКИЙ ЭКЗАМЕН.
         * @param {UserExam} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsUserExamsUpdate: async (id: number, data: UserExam, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('examsUserExamsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('examsUserExamsUpdate', 'data', data)
            const localVarPath = `/exams/user-exams/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExamsApi - functional programming interface
 * @export
 */
export const ExamsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExamsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Exam} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async examsExamsCreate(data: Exam, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Exam>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.examsExamsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Экзамен.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async examsExamsDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.examsExamsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async examsExamsList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Exam>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.examsExamsList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Экзамен.
         * @param {Exam} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async examsExamsPartialUpdate(id: number, data: Exam, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Exam>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.examsExamsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Экзамен.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async examsExamsRead(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Exam>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.examsExamsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Экзамен.
         * @param {Exam} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async examsExamsUpdate(id: number, data: Exam, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Exam>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.examsExamsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ВОПРОС.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async examsQuestionsDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.examsQuestionsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UserExam} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async examsUserExamsCreate(data: UserExam, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserExam>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.examsUserExamsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ПОЛЬЗОВАТЕЛЬСКИЙ ЭКЗАМЕН.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async examsUserExamsDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.examsUserExamsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async examsUserExamsList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserExam>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.examsUserExamsList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ПОЛЬЗОВАТЕЛЬСКИЙ ЭКЗАМЕН.
         * @param {UserExam} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async examsUserExamsPartialUpdate(id: number, data: UserExam, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserExam>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.examsUserExamsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ПОЛЬЗОВАТЕЛЬСКИЙ ЭКЗАМЕН.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async examsUserExamsRead(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserExamDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.examsUserExamsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ПОЛЬЗОВАТЕЛЬСКИЙ ЭКЗАМЕН.
         * @param {UserExam} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async examsUserExamsUpdate(id: number, data: UserExam, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserExam>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.examsUserExamsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ExamsApi - factory interface
 * @export
 */
export const ExamsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExamsApiFp(configuration)
    return {
        /**
         * 
         * @param {Exam} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsExamsCreate(data: Exam, options?: any): AxiosPromise<Exam> {
            return localVarFp.examsExamsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Экзамен.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsExamsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.examsExamsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsExamsList(options?: any): AxiosPromise<Array<Exam>> {
            return localVarFp.examsExamsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Экзамен.
         * @param {Exam} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsExamsPartialUpdate(id: number, data: Exam, options?: any): AxiosPromise<Exam> {
            return localVarFp.examsExamsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Экзамен.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsExamsRead(id: number, options?: any): AxiosPromise<Exam> {
            return localVarFp.examsExamsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Экзамен.
         * @param {Exam} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsExamsUpdate(id: number, data: Exam, options?: any): AxiosPromise<Exam> {
            return localVarFp.examsExamsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ВОПРОС.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsQuestionsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.examsQuestionsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserExam} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsUserExamsCreate(data: UserExam, options?: any): AxiosPromise<UserExam> {
            return localVarFp.examsUserExamsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ПОЛЬЗОВАТЕЛЬСКИЙ ЭКЗАМЕН.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsUserExamsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.examsUserExamsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsUserExamsList(options?: any): AxiosPromise<Array<UserExam>> {
            return localVarFp.examsUserExamsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ПОЛЬЗОВАТЕЛЬСКИЙ ЭКЗАМЕН.
         * @param {UserExam} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsUserExamsPartialUpdate(id: number, data: UserExam, options?: any): AxiosPromise<UserExam> {
            return localVarFp.examsUserExamsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ПОЛЬЗОВАТЕЛЬСКИЙ ЭКЗАМЕН.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsUserExamsRead(id: number, options?: any): AxiosPromise<UserExamDetail> {
            return localVarFp.examsUserExamsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ПОЛЬЗОВАТЕЛЬСКИЙ ЭКЗАМЕН.
         * @param {UserExam} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsUserExamsUpdate(id: number, data: UserExam, options?: any): AxiosPromise<UserExam> {
            return localVarFp.examsUserExamsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExamsApi - object-oriented interface
 * @export
 * @class ExamsApi
 * @extends {BaseAPI}
 */
export class ExamsApi extends BaseAPI {
    /**
     * 
     * @param {Exam} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamsApi
     */
    public examsExamsCreate(data: Exam, options?: AxiosRequestConfig) {
        return ExamsApiFp(this.configuration).examsExamsCreate(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Экзамен.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamsApi
     */
    public examsExamsDelete(id: number, options?: AxiosRequestConfig) {
        return ExamsApiFp(this.configuration).examsExamsDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamsApi
     */
    public examsExamsList(options?: AxiosRequestConfig) {
        return ExamsApiFp(this.configuration).examsExamsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Экзамен.
     * @param {Exam} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamsApi
     */
    public examsExamsPartialUpdate(id: number, data: Exam, options?: AxiosRequestConfig) {
        return ExamsApiFp(this.configuration).examsExamsPartialUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Экзамен.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamsApi
     */
    public examsExamsRead(id: number, options?: AxiosRequestConfig) {
        return ExamsApiFp(this.configuration).examsExamsRead(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Экзамен.
     * @param {Exam} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamsApi
     */
    public examsExamsUpdate(id: number, data: Exam, options?: AxiosRequestConfig) {
        return ExamsApiFp(this.configuration).examsExamsUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this ВОПРОС.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamsApi
     */
    public examsQuestionsDelete(id: number, options?: AxiosRequestConfig) {
        return ExamsApiFp(this.configuration).examsQuestionsDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserExam} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamsApi
     */
    public examsUserExamsCreate(data: UserExam, options?: AxiosRequestConfig) {
        return ExamsApiFp(this.configuration).examsUserExamsCreate(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this ПОЛЬЗОВАТЕЛЬСКИЙ ЭКЗАМЕН.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamsApi
     */
    public examsUserExamsDelete(id: number, options?: AxiosRequestConfig) {
        return ExamsApiFp(this.configuration).examsUserExamsDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamsApi
     */
    public examsUserExamsList(options?: AxiosRequestConfig) {
        return ExamsApiFp(this.configuration).examsUserExamsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this ПОЛЬЗОВАТЕЛЬСКИЙ ЭКЗАМЕН.
     * @param {UserExam} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamsApi
     */
    public examsUserExamsPartialUpdate(id: number, data: UserExam, options?: AxiosRequestConfig) {
        return ExamsApiFp(this.configuration).examsUserExamsPartialUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this ПОЛЬЗОВАТЕЛЬСКИЙ ЭКЗАМЕН.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamsApi
     */
    public examsUserExamsRead(id: number, options?: AxiosRequestConfig) {
        return ExamsApiFp(this.configuration).examsUserExamsRead(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this ПОЛЬЗОВАТЕЛЬСКИЙ ЭКЗАМЕН.
     * @param {UserExam} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamsApi
     */
    public examsUserExamsUpdate(id: number, data: UserExam, options?: AxiosRequestConfig) {
        return ExamsApiFp(this.configuration).examsUserExamsUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
}


